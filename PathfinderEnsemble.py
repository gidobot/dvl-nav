# PathfinderEnsemble.py
#
# Represents a Doppler Velocity Log ensemble. 
# Adapted from pd0_parser.py, written by Dave Pingal (dpingal@teledyne.com).
#   2018-11-26  dpingal@teledyne.com    implemented pd0_parser.py
#   2020-01-27  zduguid@mit.edu         implemented PathfinderEnsemble.py
#   2020-05-05  zduguid@mit.edu         reorganized code with DVL superclass 
#   2022-03-07  gburgess@mit.edu        suppport for instrument frame in derived variables
#   2022-03-08  gburgess@mit.edu        external sensors, re-calculate rel_vel_pressure
#   2022-03-09  gburgess@mit.edu        rotate water track and btm track velocities into earth frame
#                                       commented out apply_mounting_biases -- rolled into instr_to_earth 
#                                       function
#   2022-05-10  gburgess@Mit.edu        Calculate Speed of Sound using CTD and correct DVL Velocities

import numpy as np 
import pandas as pd
import scipy
import struct
import sys
from datetime import datetime
from PathfinderDVL import PathfinderDVL
from PathfinderChecksumError import PathfinderChecksumError


class PathfinderEnsemble(PathfinderDVL):
    def __init__(self, pd0_bytes, prev_ensemble=None, gps_fix=None, ros_time=None, ext_roll=None, \
                  ext_pitch=None, ext_heading=None, ext_depth=None, ext_temp=None, ext_cond=None):
        """Constructor for a Doppler Velocity Log (DVL) Ensemble object. 

        The 'Pathfinder Doppler Velocity Log (DVL) 600 kHz' user manual was 
        consulted while writing this code. Specific pages of the manual are 
        referenced in the doc-strings of relevant functions.

        The Pathfinder always sends the Least Significant Byte (LSB) first.
        This corresponds with little-endian byte ordering. As a result, the 
        less-than symbol (<) is included in the format string so that the 
        struct module can unpack the bytes properly using the function below:

        struct.unpack_from(format-string, buffer, offset=0)
        (https://docs.python.org/3/library/struct.html)

        Args: 
            pd0_bytes: pd0 bytes to be parsed into a DVL ensemble.
            prev_ensemble: previously collected PathfinderEnsemble. The 
                previous ensemble is used for deducing Pathfinder 
            gps_fix: (x,y) GPS location, used to update the position of the  
                relative frame. As a result, every dive (both start of mission
                and every subsequent surfacing) will have a different relative
                frame of reference.
            ros_time: Unix timestamp from ros msg containing raw dvl ensemble. More
                accurate than DVLs internal clock.
            ext_roll: [deg] vehicle roll from external sensor. For unit 770, SpartonM2
                AHRS
            ext_pitch: [deg] vehicle pitch from external sensor. For unit 770, SpartonM2
                AHRS
            ext_heading: [deg] vehicle heading from external sensor. For unit 770, SpartonM2
                AHRS
            ext_depth: [m] vehicle depth from external sensor. For unit 770, CTD 
                (should it be m_depth?)
            ext_temp: [C] degrees Celcius temperature from external sensor. For
                 Unit 770, CTD
            ext_cond: [S/m] conductivity frome external sensor. For Unit 770, CTD


        Returns:
            A new Ensemble that has been parsed from the given pd0 bytes, or 
            None if there was an error while parsing.

        Raises:
            ValueError if header id is incorrect.
            PathfinderChecksumError if an invalid checksum is found.
        """
        # use the parent constructor for defining Pathfinder DVL variables
        super().__init__()

        # initialize Micron Ensemble data array based on number of variables
        self._data_array = np.zeros(self.ensemble_size)

        # store the previous ensemble and GPS fix information
        self._prev_ensemble = prev_ensemble
        self._gps_fix = gps_fix
        
        # associated ros timestamp of raw dvl ensemble
        self._ros_time = ros_time

        # Euler angles generated by external AHRS (Sparton for unit 770)
        self._ext_roll = ext_roll
        self._ext_pitch = ext_pitch
        self._ext_heading = ext_heading

        # CTD information
        self._ext_depth = ext_depth
        self._ext_temp = ext_temp
        self._ext_cond = ext_cond

        # map from byte id to parsing function 
        self._data_id_parsers = {
            0x0000: ('fixed_leader',    self.parse_fixed_leader),
            0x0080: ('variable_leader', self.parse_variable_leader),
            0x0100: ('velocity',        self.parse_water_profiling_data),
            0x0200: ('correlation',     self.parse_water_profiling_data),
            0x0300: ('echo_intensity',  self.parse_water_profiling_data),
            0x0400: ('percent_good',    self.parse_water_profiling_data),
            0x0600: ('bottom_track',    self.parse_bottom_track),
        }

        # parse array given pd0 bytes
        self.parse_ensemble(pd0_bytes)


    @property
    def data_array(self):
        return self._data_array

    @property
    def prev_ensemble(self):
        return self._prev_ensemble

    @property
    def gps_fix(self):
        return self._gps_fix
    
    @property
    def ros_time(self):
        return self._ros_time
    
    @property
    def ext_roll(self):
        return self._ext_roll
    
    @property
    def ext_pitch(self):
        return self._ext_pitch

    @property
    def ext_heading(self):
        return self._ext_heading
    
    @property
    def ext_depth(self):
        return self._ext_depth
    
    @property
    def ext_temp(self):
        return self._ext_temp
    
    @property
    def ext_cond(self):
        return self._ext_cond
  
    @property
    def data_id_parsers(self):
        return self._data_id_parsers
    
    @property
    def data_type_offsets(self):
        return self._data_type_offsets

    @property
    def address_offsets(self):
        return self._address_offsets
    
    @property
    def var_byte_sizes(self):
        return self._var_byte_sizes


    def get_data(self, var):
        """Getter method for a give variable in the data array"""
        if (var not in self.label_set):
            raise ValueError("bad variable for: get(%s)" % (var))
        else:
            return self.data_array[self.data_lookup[var]]


    def set_data(self, var, val, attribute=True):
        """Setter method for a variable-value pair to be put in the array"""
        if (var not in self.label_set):
            raise ValueError("bad variable for: set(%s, %s)" % (var, str(val)))
        self._data_array[self.data_lookup[var]] = val 
        if attribute: setattr(self, var, val)    


    def parse_ensemble(self, pd0_bytes):
        """Parses an ensemble from pd0 bytes.

        Pseudocode for decoding a pd0 ensemble:
        1. locate the header data via the header id (7F7F).
        2. validate the checksum to confirm a valid ensemble.
        3. locate the number of data types.
        4. locate the offset for each data type.
        5. locate the data type bytes using the offset and data type id.
        6. parse the data type using the Pathfinder byte specification.

        Pseudocode for decoding a sequence in the Pathfinder Manual on pg 241.

        Args:
            pd0_bytes: pd0 bytes to be parsed into a DVL ensemble.
        """
        # constant used for unpacking bytes
        HEADER_ID = 'H' 

        # parse header to confirm header ID and validate checksum
        self.parse_header(pd0_bytes)
        self.validate_checksum(pd0_bytes)

        # parse each data type 
        for address in self.address_offsets:
            header_id = struct.unpack_from(HEADER_ID, pd0_bytes, address)[0]
            if header_id in self.data_id_parsers:
                name      = self.data_id_parsers[header_id][0]
                parser    = self.data_id_parsers[header_id][1]
                data_dict = parser(pd0_bytes, name, address)
            else:
                print('  WARNING: no parser found for header %d' %(header_id,))

        # parse derived variables 
        self.parse_derived_variables()


    def unpack_bytes(self, pd0_bytes, format_tuples, offset=0):
        """Unpacks pd0 bytes into data format types.

        Args:
            pd0_bytes: bytes to be parsed into specified data types.
            format_tuples: tuple of variable format tuples,
                where each variable format tuple is of the form:
                (name <string>, format-string <char>, offset <int>).
            offset: byte offset to start reading the pd0 bytes.

        Returns:
            Dictionary representing the parsed data types, where the keys of
            the dictionary are var-name and the values are the parsed values.

        Note: Information table for common Format Strings: 
            format  type                size 
            x       pad-byte 
            c       char                1
            b       signed-char         1
            B       unsigned char       1
            h       short               2
            H       unsigned short      2
            i       int                 4
            I       unsigned int        4
            >i      big-endian int      1
            <i      little-endian int   1
            q       long long           8
            Q       unsigned long long  8 
        (taken from: https://docs.python.org/3/library/struct.html)
        """
        data = {}
        for format_tuple in format_tuples:
            var_name        = format_tuple[0]
            var_format      = format_tuple[1]
            var_size        = struct.calcsize(var_format)
            var_offset      = offset + format_tuple[2]
            data[var_name]  = struct.unpack_from(var_format,
                                                 pd0_bytes,
                                                 var_offset)[0]
        return(data)


    def parse_header(self, pd0_bytes):
        """Parses the header portion of the pd0 file. 

        The pd0 header format is defined in the Pathfinder Manual on pg 172.
        The header size is: 6 + [2 * num_data_types] bytes. Stores header 
        information as attributes of the Ensemble class.

        Args:
            pd0_bytes: bytes fro the PD0 file to be parsed as the header.

        Raises: 
            ValueError if header id is incorrect.
        """
        HEADER_FLAG    = 0x7f    # flag to indicate start of header
        HEADER_BYTES   = 6       # number of bytes before address offsets
        ADDRESS_FORMAT = '<H'    # format string of the header addresses

        # unpack the header bytes from the byte array
        header_dict = self.unpack_bytes(pd0_bytes, self.header_format)

        # check that header has the correct ID
        if (header_dict['id']          != HEADER_FLAG or 
            header_dict['data_source'] != HEADER_FLAG):
            raise ValueError('Incorrect Header ID \
                \n  received: %s %s \n  expected: %s %s' % 
                (header_dict['id'], header_dict['data_source'], 
                 HEADER_FLAG, HEADER_FLAG))

        # if header has correct ID, store the remaining header values 
        self.header_id          = header_dict['id']
        self.header_data_source = header_dict['data_source']
        self.num_data_types     = header_dict['num_data_types']
        self.num_bytes          = header_dict['num_bytes']

        # parse the address offsets given 
        address_size    = struct.calcsize(ADDRESS_FORMAT)
        address_end     = HEADER_BYTES + self.num_data_types*address_size
        address_offsets = []

        # parse the address offset for each data type 
        for start in range(HEADER_BYTES, address_end, address_size):
            address = struct.unpack_from(ADDRESS_FORMAT, pd0_bytes, start)[0]
            address_offsets.append(address)
        self._address_offsets = address_offsets

        # determine the byte sizes of each variable type
        sizes = self.address_offsets.copy()
        sizes.insert(0,0)
        sizes.append(self.num_bytes)
        self._var_byte_sizes = \
            [sizes[i+1] - sizes[i] for i in range(len(sizes)-1)]


    def parse_fixed_leader(self, pd0_bytes, name, offset):
        """Parses the fixed leader data type of the pd0 file.

        The pd0 fixed leader format is in the Pathfinder Manual on pg 174.
        The fixed leader size is: 58 bytes.

        Args:
            pd0_bytes: pd0 bytes to be parsed into the fixed leader data type.
            name: the name of the data type (name = 'fixed_leader')
            offset: byte offset to start parsing the fixed leader. 
        """
        fixed_leader = self.unpack_bytes(pd0_bytes,
                                         self.fixed_leader_format,
                                         offset)

        # add relevant fixed leader values to the data array
        for key in fixed_leader:
            if key in self.label_set:
                self.set_data(key, fixed_leader[key])

        # convert relevant fields to standard metric quantities
        self.convert_to_metric('depth_bin_length',        self.CM_TO_M)
        self.convert_to_metric('blanking_distance',       self.CM_TO_M)
        self.convert_to_metric('error_velocity_threshold',self.MM_TO_M)
        self.convert_to_metric('heading_alignment',       self.HUNDRETH_TO_DEG)
        self.convert_to_metric('heading_bias',            self.HUNDRETH_TO_DEG)
        self.convert_to_metric('bin0_distance',           self.CM_TO_M)
        self.convert_to_metric('transmit_pulse_length',   self.CM_TO_M)

        # raise error if received too many bins 
        #   + expect 40 bins exactly 
        #   + this is performed to make array processing more efficient 
        if self.num_bins != self.NUM_BINS_EXP:
            raise ValueError('Too many bins: expected = %s, actual = %s'
                             % (self.NUM_BINS_EXP, self.num_bins))

        # raise error if incorrect number of beams 
        #   + expect exactly four beams for the Pathfinder DVL 
        if self.num_beams != self.NUM_BEAMS_EXP:
            raise ValueError('Incorrect # beams: expected = %s, actual = %s'
                             % (self.NUM_BEAMS_EXP, self.num_beams))

        # compute expected sizes of each data type for diagnostic purposes
        #   + according to the Pathfinder manual pg 171
        #   + compare this against self.var_byte_sizes
        self.var_byte_sizes_expected = [
            6 + 2*self.num_data_types,          # header
            58,                                 # fixed leader
            77,                                 # variable leader
            2+2*self.num_beams*self.num_bins,   # velocity 
            2 + self.num_beams*self.num_bins,   # correlation
            2 + self.num_beams*self.num_bins,   # echo intensity
            2 + self.num_beams*self.num_bins,   # percent good,
            81                                  # bottom track
        ]            


    def parse_variable_leader(self, pd0_bytes, name, offset):
        """Parses the variable leader data type of the pd0 file.

        The pd0 variable leader format is in the Pathfinder Manual on pg 180.
        The variable leader size is: 77 bytes.

        Args:
            pd0_bytes: pd0 bytes to be parsed into the variable leader type.
            name: the name of the data type (name = 'variable_leader')
            offset: byte offset to start parsing the variable leader 
        """
        # assumes data collected in the 2000's (not recorded by DVL)
        RTC_MILLENIUM = 2000 
        variable_leader = self.unpack_bytes(pd0_bytes, 
                                            self.variable_leader_format, 
                                            offset)
        
        # add relevant variable leader values to the data array
        for key in variable_leader:
            if key in self.label_set:
                self.set_data(key, variable_leader[key])

        # compute ensemble number while accounting for ensemble roll over 
        self.set_data('ensemble_number', variable_leader['ensemble_number'] + \
                        self.MAX_ENS_NUM*variable_leader['ensemble_rollover'])

        # convert data to metric values when applicable 
        self.convert_to_metric('depth',                   self.DM_TO_M)
        self.convert_to_metric('heading',                 self.HUNDRETH_TO_DEG)
        self.convert_to_metric('pitch',                   self.HUNDRETH_TO_DEG)
        self.convert_to_metric('roll',                    self.HUNDRETH_TO_DEG)
        self.convert_to_metric('temperature',             self.HUNDRETH_TO_DEG)
        self.convert_to_metric('pitch_standard_deviation',self.TENTH_TO_DEG)
        self.convert_to_metric('roll_standard_deviation', self.TENTH_TO_DEG)
        self.convert_to_metric('pressure',                self.DAM_TO_M)
        self.convert_to_metric('pressure_variance',       self.DAM_TO_M)

        # collect all time information into a single datetime object 
        timestamp = datetime(
            variable_leader['rtc_year'] + RTC_MILLENIUM,
            variable_leader['rtc_month'],
            variable_leader['rtc_day'],
            variable_leader['rtc_hour'],
            variable_leader['rtc_minute'],
            variable_leader['rtc_second'],
            variable_leader['rtc_hundredths']).timestamp()

        # store time information in data array
        self.set_data('time', timestamp)


    def parse_water_profiling_data(self, pd0_bytes, name, offset):
        """Parses the water profiling data type of the pd0 file.

        The water profiling format is in the Pathfinder Manual on pg 188 & 190.
        The velocity size is: 2 + [2 * num_beams * num_cells] bytes.
        The other profiling sizes are: 2 + [num_beams * num_cells] bytes.

        Velocity:       [mm/s]
        Correlation:    [0, 255]
        Echo Intensity: [0.61 dB per count]
        Percent Good:   [0, 100]

        Args:
            pd0_bytes: pd0 bytes to be parsed into the water profiling type.
            name: the name of the data type 
            offset: byte offset to start parsing the water profiling 
        """
        ID_BYTE_LENGTH   = 2
        if name == 'velocity': profiling_format = '<h'
        else:                  profiling_format = 'B'
        offset  += ID_BYTE_LENGTH
        profile  = self.parse_beams(pd0_bytes, offset, self.num_bins,
                                    self.num_beams, profiling_format, name)


    def parse_bottom_track(self, pd0_bytes, name, offset):
        """Parses the bottom track data type of the pd0 file.

        The pd0 bottom track format is in the Pathfinder Manual on pg 194.
        The bottom track size is: 81 bytes.

        Args:
            pd0_bytes: pd0 bytes to be parsed into the bottom track type.
            name: the name of the data type (name = 'bottom_track')
            offset: byte offset to start parsing the bottom track 
        """
        # labels for (u,v,w) components of velocity
        label_u = 'btm_beam0_velocity'
        label_v = 'btm_beam1_velocity'
        label_w = 'btm_beam2_velocity'
        bottom_track = self.unpack_bytes(pd0_bytes,
                                         self.bottom_track_format,
                                         offset)

        # add relevant bottom track values to the data array
        for key in bottom_track:
            if key in self.label_set:
                self.set_data(key, bottom_track[key])

        # helper functions for converting velocity values
        def convert_special_to_metric(var, flag, multiplier):
            if self.get_data(var) == flag:  
                self.set_data(var, np.NaN)
            else: 
                self.convert_to_metric(var, multiplier)

        def convert_velocity_to_metric(var):
            convert_special_to_metric(var, self.BAD_VELOCITY, self.MM_TO_M)

        def convert_bt_range_to_metric(var):
            convert_special_to_metric(var, self.BAD_BT_RANGE, self.CM_TO_M)

        # convert relevant fields to standard metric quantities
        convert_velocity_to_metric('btm_beam0_velocity')
        convert_velocity_to_metric('btm_beam1_velocity')
        convert_velocity_to_metric('btm_beam2_velocity')
        convert_velocity_to_metric('btm_beam3_velocity')
        convert_bt_range_to_metric('btm_beam0_range')
        convert_bt_range_to_metric('btm_beam1_range')
        convert_bt_range_to_metric('btm_beam2_range')
        convert_bt_range_to_metric('btm_beam3_range')
        self.convert_to_metric('btm_max_error_velocity', self.MM_TO_M)
        self.convert_to_metric('btm_beam0_rssi',         self.COUNT_TO_DB)
        self.convert_to_metric('btm_beam1_rssi',         self.COUNT_TO_DB)
        self.convert_to_metric('btm_beam2_rssi',         self.COUNT_TO_DB)
        self.convert_to_metric('btm_beam3_rssi',         self.COUNT_TO_DB)

        # fix velocity 
        u0    = self.get_data(label_u)
        v0    = self.get_data(label_v) 
        w0    = self.get_data(label_w)
        #u,v,w = self.apply_mounting_bias_rotations((u0,v0,w0))
        u,v,w = self.apply_sound_speed_correction((u0,v0,w0))
        # DVL assumes bottom is moving, not vehicle. Hence sign flip for all velocities.
        u,v,w = self.apply_instr_to_earth((u,v,w))
        self.set_data(label_u, u)
        self.set_data(label_v, v)
        self.set_data(label_w, w)
 
    def medwin_calculate_speed_of_sound(self, depth, temp, salinity):
        # Based on H. Medwin (1975)
        # Temp in degrees Celsius
        # Depth in Meters
        # Salinity in parts per thousand
        speed_of_sound = 1449.2 + 4.6 * temp - 0.055 * temp**2 + 0.00029 * temp**3 + (1.34 - 0.01 * temp) * (salinity - 35) + 0.016 * depth
        return speed_of_sound
    
    def apply_sound_speed_correction(self,v0):
        u,v,w = v0
        if self.ext_cond and self.ext_depth and self.ext_temp:
            speed_of_sound = self.medwin_calculate_speed_of_sound(self.ext_depth, self.ext_temp, self.ext_cond*6.4)
            scale_factor = self.USED_SPEED_OF_SOUND / speed_of_sound
            u_scaled = u*scale_factor
            v_scaled = v*scale_factor
            w_scaled = w*scale_factor
        else:
            u_scaled = u
            v_scaled = v
            w_scaled = w
        return (u_scaled, v_scaled, w_scaled)


    def parse_derived_variables(self):
        """Computes the derived variables specified in PathfinderDVL.

        Uses information from other variables 
        """

        # check that the DVL is reporting data in earth coordinates or instrument coords
        INSTRUMENT_FRAME = 'Instrument Coords'
        EARTH_FRAME = 'Earth Coords'
        # MIN_PITCH   = 0.001
        MIN_PITCH   = 0.0001
        # MIN_PITCH   = 1.0
        EPSILON     = 0.001
        # Theoretical Max Limit for Speed 
        # MAX_SPEED   = 1.00 # Experimental Max Limit for unit 770 in Puerto Rico is approx 1.0 m/s (35 deg, full thrust, full pump, terminal velocity to 500m dive)
        MAX_SPEED   = 1.3

        coordinate_frame = self.parse_coordinate_transformation(verbose=False)
        if (coordinate_frame != EARTH_FRAME) and (coordinate_frame != INSTRUMENT_FRAME):
            raise ValueError('Bad coord frame: expected = %s or %s, actual = %s' % 
                             (EARTH_FRAME, INSTRUMENT_FRAME, coordinate_frame))

        # Assumes use of external sensors if using Instrument frame
        if coordinate_frame == INSTRUMENT_FRAME:
            EXT_SENSORS = True
        elif coordinate_frame == EARTH_FRAME:
            EXT_SENSORS = False

        # External Sensors
        if self.ros_time:
            self.set_data('ros_timestamp', self.ros_time)
        if self.ext_roll:
            self.set_data('ahrs_roll', self.ext_roll)
        if self.ext_pitch:
            self.set_data('ahrs_pitch', self.ext_pitch)
        if self.ext_heading:
            self.set_data('ahrs_heading', self.ext_heading)
        if self.ext_depth:
            self.set_data('ctd_depth', self.ext_depth)
        if self.ext_temp:
            self.set_data('ctd_temp', self.ext_temp)
        if self.ext_cond:
            self.set_data('ctd_cond', self.ext_cond)

        if self.ext_depth and self.ext_temp and self.ext_cond:
            salinity_ppt = self.ext_cond * 6.4 # Convert Siemen/meter to parts per thousand
            depth = float(self.ext_depth)
            temp = float(self.ext_temp)
            # print(type(salinity_ppt), type(depth), type(temp))
            speed_of_sound_est = self.medwin_calculate_speed_of_sound(depth, temp, salinity_ppt)
            self.set_data('ctd_speed_of_sound', speed_of_sound_est)

        # previous ensemble not given
        #   + assume beginning of dive
        if not self.prev_ensemble:
            # set origin to (0,0) if not specified
            if not self.gps_fix:
                self.set_data('origin_x',  0)
                self.set_data('origin_y',  0)
            # otherwise set origin to GPS fix 
            else:
                self.set_data('origin_x',  self.gps_fix[0])
                self.set_data('origin_y',  self.gps_fix[0])
            return

        # extract position information from previous ensemble 
        #   + performs odometry without computation of ocean currents
        #   + odometry with water column currents is not embedded right now
        prev_origin_x  = self.prev_ensemble.get_data('origin_x')
        prev_origin_y  = self.prev_ensemble.get_data('origin_y')
        prev_rel_pos_x = self.prev_ensemble.get_data('rel_pos_x_dvl_dr')
        prev_rel_pos_y = self.prev_ensemble.get_data('rel_pos_y_dvl_dr')
        prev_rel_pos_z = self.prev_ensemble.get_data('rel_pos_z_dvl_dr')
        if EXT_SENSORS:
            prev_depth     = self.prev_ensemble.get_data('ctd_depth')
            prev_pitch     = self.prev_ensemble.get_data('ahrs_pitch')
            prev_t         = self.prev_ensemble.get_data('ros_timestamp') 
        else:
            prev_depth     = self.prev_ensemble.get_data('depth')
            prev_pitch     = self.prev_ensemble.get_data('pitch')
            prev_t         = self.prev_ensemble.get_data('time') 

        # helper function for setting DVL velocity based on bin number
        def set_dvl_rel_velocities(bin_num):
            u_var = self.get_profile_var_name('velocity', bin_num, 0)
            v_var = self.get_profile_var_name('velocity', bin_num, 1)
            w_var = self.get_profile_var_name('velocity', bin_num, 2)
            u = self.get_data(u_var)
            v = self.get_data(v_var)
            w = self.get_data(w_var)
            self.set_data('rel_vel_dvl_u', -u)
            self.set_data('rel_vel_dvl_v', -v)
            self.set_data('rel_vel_dvl_w',  -w)

        # helper function for setting bottom track velocities
        def set_btm_abs_velocities():
            u = -self.btm_beam0_velocity
            v = -self.btm_beam1_velocity
            w = -self.btm_beam2_velocity
            self.set_data('abs_vel_btm_u', u)
            self.set_data('abs_vel_btm_v', v)
            self.set_data('abs_vel_btm_w', w)

    
        # helper function to update relative position 
        def update_position(vel_label):
            vel_options = ['rel_vel_dvl','rel_vel_pressure','abs_vel_btm']
            if vel_label not in vel_options:
                raise ValueError('bad velocity source: %s' % (vel_label))
            # update relative position using bottom track velocity 
            delta_z = self.delta_z_pressure
            self.set_data('delta_x',self.delta_t*self.get_data(vel_label+'_u'))
            self.set_data('delta_y',self.delta_t*self.get_data(vel_label+'_v'))
            self.set_data('delta_z',self.delta_t*self.get_data(vel_label+'_w'))
            self.set_data('rel_pos_x_dvl_dr', prev_rel_pos_x + self.delta_x)
            self.set_data('rel_pos_y_dvl_dr', prev_rel_pos_y + self.delta_y)
            self.set_data('rel_pos_z_dvl_dr', prev_rel_pos_z +      delta_z)

        # helper function for assessing if bottom track data is valid
        def valid_bottom_track():
            return(not np.isnan(self.get_data('btm_beam0_velocity')))

        def valid_bin_num(bin_num):
            var_name = self.get_profile_var_name('velocity', bin_num, 0)
            return(not np.isnan(self.get_data(var_name)))


        # compute through water velocity from pressure method

        if EXT_SENSORS:
            self.set_data('delta_t',          self.ros_time  - prev_t)
            self.set_data('delta_z_pressure', self.ext_depth - prev_depth)
            self.set_data('delta_pitch',      self.ext_pitch - prev_pitch)
            current_pitch = self.ext_pitch
            current_heading = self.ext_heading
        else:
            self.set_data('delta_t',          self.time  - prev_t)
            self.set_data('delta_z_pressure', self.depth - prev_depth)
            self.set_data('delta_pitch',      self.pitch - prev_pitch)
            current_pitch = self.pitch
            current_heading = self.heading
        
        # select DVL bin for through-water velocity 
        #   + first two bins are less accurate in steady state conditions
        #   + bins further away are more likely to have random outliers
        for i in [2,1,0]:
            if valid_bin_num(i) and self.get_speed(i) < MAX_SPEED:
                set_dvl_rel_velocities(i)
                current_speed = self.get_horizontal_speed(i)
                break

        # self.set_data('speed_mag', current_speed)          

        # set bottom-track velocities (even if NaN)
        set_btm_abs_velocities()

        # Dynamic Angle of Attack Experimentation
        # current_glider_path_angle = (13.76 * (current_speed**2)) + (37.02 * current_speed) + 0.3372
        # if current_pitch > 0:
        #     AoA = current_glider_path_angle - current_pitch
        # else:
        #     AoA = (-1*current_glider_path_angle) - current_pitch
        # self.set_data('angle_of_attack', AoA)

        #assume static angle of attack
        # if current_pitch > 0:
        #     AoA = 3
        # else:
        #     AoA = -3
        # self.set_data('angle_of_attack', AoA)

        self.set_data('angle_of_attack', 0)

        # computer horizontal velocity in relative frame 
        #   + avoid division by zero
        if (np.abs(current_pitch) > MIN_PITCH) and \
            (np.abs(self.get_data('delta_z_pressure')) > EPSILON):
            
            # through water velocity from change in pressure and compass
            self.set_data('rel_vel_pressure_w', 
                        self.delta_z_pressure/self.delta_t)

            # horizontal velocity depends on pitch value
            rel_vel_h = self.rel_vel_pressure_w / \
                        np.tan(-current_pitch*self.DEG_TO_RAD - (self.get_data('angle_of_attack')*self.DEG_TO_RAD))

            rel_vel_u = rel_vel_h*np.sin(current_heading*self.DEG_TO_RAD)
            rel_vel_v = rel_vel_h*np.cos(current_heading*self.DEG_TO_RAD)
            if ((np.abs(rel_vel_u) < MAX_SPEED) and (np.abs(rel_vel_v) < MAX_SPEED)):
                self.set_data('rel_vel_pressure_u', rel_vel_u)
                self.set_data('rel_vel_pressure_v', rel_vel_v)
            else:
                self.set_data('rel_vel_pressure_u', np.NaN)
                self.set_data('rel_vel_pressure_v', np.NaN)

        # set pressure through water velocities to NaN otherwise
        else:
            self.set_data('rel_vel_pressure_u', np.NaN)
            self.set_data('rel_vel_pressure_v', np.NaN)
            self.set_data('rel_vel_pressure_w', np.NaN)

        # update relative position using bottom track velocity or DVL velocity
        if valid_bottom_track():
            update_position('abs_vel_btm')
        else:
            update_position('rel_vel_dvl')
        
        # update origin and relative position if GPS fix is given
        if self.gps_fix:
            self.set_data('origin_x', self.gps_fix[0])
            self.set_data('origin_y', self.gps_fix[0])
            self.set_data('rel_pos_x_dvl_dr', 0)
            self.set_data('rel_pos_y_dvl_dr', 0)
            self.set_data('rel_pos_z_dvl_dr', 0)
        else:
            self.set_data('origin_x', prev_origin_x)
            self.set_data('origin_y', prev_rel_pos_y)

        # compute three factors of bathymetry: depth, slope, and orient
        self.get_bathy_factors()


    def Qx(self, phi):
        """Orthogonal rotation matrix about x-axis by angle phi
        """
        return(np.array([[           1,            0,            0],
                         [           0,  np.cos(phi), -np.sin(phi)],
                         [           0,  np.sin(phi),  np.cos(phi)]]))


    def Qy(self, phi):
        """Orthogonal rotation matrix about y-axis by angle phi
        """
        return(np.array([[ np.cos(phi),            0,  np.sin(phi)],
                         [           0,            1,            0],
                         [-np.sin(phi),            0,  np.cos(phi)]]))


    def Qz(self, phi):
        """Orthogonal rotation matrix about z-axis by angle phi
        """
        return(np.array([[ np.cos(phi), -np.sin(phi),            0],
                         [ np.sin(phi),  np.cos(phi),            0],
                         [           0,            0,            1]]))


    def get_speed(self, bin_num):
        """Returns the magnitude of velocity given a bin number

        Args:
            bin_num: the bin number to compute the speed vector
        """
        x,y,z = 0,1,2
        u = self.get_data(self.get_profile_var_name('velocity', bin_num, x))
        v = self.get_data(self.get_profile_var_name('velocity', bin_num, y))
        w = self.get_data(self.get_profile_var_name('velocity', bin_num, z))
        return(np.linalg.norm([u,v,w]))

    def get_horizontal_speed(self, bin_num):
        x,y = 0,1
        u = self.get_data(self.get_profile_var_name('velocity', bin_num, x))
        v = self.get_data(self.get_profile_var_name('velocity', bin_num, y))
        return(np.linalg.norm([u,v]))



    def convert_to_metric(self, variable, multiplier, attribute=True):
        """Converts variable to standard metric value using the multiplier"""
        value = self.get_data(variable) 
        self.set_data(variable, value * multiplier, attribute)
        

    def validate_checksum(self, pd0_bytes):
        """Validates the checksum for the ensemble.
        """
        calc_checksum  = sum([c for c in pd0_bytes[:self.num_bytes]]) & 0xFFFF
        given_checksum = struct.unpack_from('<H', pd0_bytes, self.num_bytes)[0]
        if calc_checksum != given_checksum:
            raise PathfinderChecksumError(calc_checksum, given_checksum)


    def apply_mounting_bias_rotations(self, velocity0):
        """Rotates velocity vector to account for mounting bias.

        Assumes that velocity data is in Earth Coordinate frame.

        Args:
            velocity0: (u0,v0,w0) velocity vector recorded by instrument.

        Returns: (u,v,w) velocity vector in desired coordinate frame.
        """
        u0,v0,w0     = velocity0
        V_earth0     = np.array([[u0],[v0],[w0]])

        # rotate from Earth Coords <E,N,U> to Ship Coords <S,F,U>
        heading           =  self.heading*self.DEG_TO_RAD
        heading_bias      = (self.heading-self.BIAS_HEADING)*self.DEG_TO_RAD
        pitch_bias        =  self.BIAS_PITCH*self.DEG_TO_RAD        
        roll_bias         =  self.BIAS_ROLL*self.DEG_TO_RAD
        V_ship            = np.dot(self.Qz( heading),      V_earth0)
        V_ship_pitch      = np.dot(self.Qx( pitch_bias),   V_ship)
        V_ship_pitch_roll = np.dot(self.Qy( roll_bias),    V_ship_pitch)
        V_earth           = np.dot(self.Qz(-heading_bias), V_ship_pitch_roll)
        u,v,w             = V_earth.flatten()
        return(u,v,w)

    def apply_instr_to_earth(self, velocity0):
        u0,v0,w0       = velocity0
        V_inst         = np.array([[u0], [v0], [w0]])
        
        # rotate velocities from instrument Coords y (FWS), x (STBD), z (DOWN) to Earth Coords <E, N, U>
        # heading is made negativ ebecause AHRS measures yaw with z down ship frame notation (CW) whereas U is up and yaw should be CCW
        heading = (self.ext_heading + self.BIAS_HEADING) * self.DEG_TO_RAD*-1
        roll    = (self.ext_roll + self.BIAS_ROLL) * self.DEG_TO_RAD
        pitch   = (self.ext_pitch + self.BIAS_PITCH) * self.DEG_TO_RAD

        Qx = self.Qx(pitch)
        Qy = self.Qy(roll)
        Qz = self.Qz(heading)
        R1 = np.dot(Qy, V_inst)
        R2 = np.dot(Qx, R1)
        V_ENU = np.dot(Qz, R2)
        u,v,w = V_ENU.flatten()

        return(u,v,w)

    #TODO Review roatations
    def get_bathy_factors(self):
        """Computes three factors of bathymetry: depth, slope, & orientation"""
        # convert bottom-track vertical range to slant range
        sin_janus = np.sin(self.JANUS_ANGLE*self.DEG_TO_RAD)
        cos_janus = np.cos(self.JANUS_ANGLE*self.DEG_TO_RAD)
        slant_ranges = {
            'r1' : self.get_data('btm_beam0_range') / cos_janus,
            'r2' : self.get_data('btm_beam1_range') / cos_janus,
            'r3' : self.get_data('btm_beam2_range') / cos_janus,
            'r4' : self.get_data('btm_beam3_range') / cos_janus,
        }

        # ignore case when less than three ranges are available
        min_valid_slant_ranges = 3 
        valid_slant_ranges = {key:slant_ranges[key] for key in 
            slant_ranges.keys() if not np.isnan(slant_ranges[key])}

        if len(valid_slant_ranges) < min_valid_slant_ranges:
            self.set_data('bathy_factor_depth',  np.nan)
            self.set_data('bathy_factor_slope',  np.nan)
            self.set_data('bathy_factor_orient', np.nan)
            return()

        # extract bottom contact positions in instrument coordinate frame
        inst_coords = []
        for key in valid_slant_ranges:
            r = valid_slant_ranges[key]
            z = r*cos_janus # z -> vertical component 
            h = r*sin_janus # h -> horizontal component
            if   key == 'r1': inst_coords.append(np.array([[-h], [ 0], [-z]]))
            elif key == 'r2': inst_coords.append(np.array([[ h], [ 0], [-z]]))
            elif key == 'r3': inst_coords.append(np.array([[ 0], [ h], [-z]]))
            elif key == 'r4': inst_coords.append(np.array([[ 0], [-h], [-z]]))

        # rotate instrument coordinates into the world frame using Euler angles
        earth_coords = []
        Qx = self.Qx((self.pitch   + self.BIAS_PITCH)   * self.DEG_TO_RAD)
        Qy = self.Qy((self.roll    + self.BIAS_ROLL)    * self.DEG_TO_RAD)
        Qz = self.Qz((self.heading + self.BIAS_HEADING) * self.DEG_TO_RAD)
        for pos in inst_coords:
            earth_coords.append(np.dot(Qz, np.dot(Qy, np.dot(Qx, pos))))

        # use least squares approach to find planar surface of best fit
        A = np.array([np.append(x[0:2].T, [1]) for x in earth_coords])
        b = np.array([x[2] for x in earth_coords])
        fit, residual, rnk, s = scipy.linalg.lstsq(A,b)

        # fit = [a, b, c] s.t. z = ax + by + c
        a,b,c  = tuple(fit)
        bathy_depth  = self.depth - c
        bathy_slope  = np.arctan((a**2 + b**2)**0.5)*self.RAD_TO_DEG
        bathy_orient = np.arctan2(-a, -b)*self.RAD_TO_DEG
        self.set_data('bathy_factor_depth',  bathy_depth)
        self.set_data('bathy_factor_slope',  bathy_slope)
        self.set_data('bathy_factor_orient', bathy_orient)


    def parse_beams(self, pd0_bytes, offset, num_bins, num_beams, var_format, 
        var_name):
        """Parses beams of DVL data.
        
        Velocity, correlation mag, echo intensity, and percent good data types
        report values per depth cell per beam. For example, with 4 beams
        and 40 depth cell bins, there are 160 velocity values reported 
        (each value being encoded with two bytes, unlike the other fields).

        Args:
            pd0_bytes: pd0 bytes to be parsed into the fixed leader data type.
            offset: byte offset to start parsing the fixed leader. 
            num_bins: number of depth cells on DVL (user setting).
            num_beams: number of beams on the DVL (fixed at 4).
            var_format: Format String for the variable being parsed for each
                beam. For example var_format = 'h' means type short.
            var_name: name of the variable being parsed (i.e. 'velocity')
        """
        # assumes that last beam is an error velocity, meaning velocity is not
        # reported in beam coordinates 
        ERROR_BEAM_NUM = 3
        beam_u = 0
        beam_v = 1
        beam_w = 2
        var_size  = struct.calcsize(var_format)
        velocity0 = []
        num_good_vel_bins_flag = False

        # only parse velocity water profile data to save processing time
        if var_name == 'velocity':

            # parse data for each depth cell 
            for bin_num in range(num_bins):
                bin_start = offset + bin_num*num_beams*var_size

                # parse data for each beam for a given depth cell 
                velocity0  = []
                for beam_num in range(num_beams):
                    beam_start = bin_start + beam_num*var_size
                    data_val   = struct.unpack_from(var_format, 
                                                    pd0_bytes, 
                                                    beam_start)[0]

                    # compute labels and array index 
                    label = self.get_profile_var_name(var_name, 
                                                      bin_num, 
                                                      beam_num)

                    # filter out bad velocity values 
                    if (var_name == 'velocity'):
                        if (data_val == self.BAD_VELOCITY):
                            self.set_data(label, np.NaN)
                            if not num_good_vel_bins_flag:
                                self.set_data('num_good_vel_bins', bin_num)
                                num_good_vel_bins_flag = True
                        elif (beam_num != ERROR_BEAM_NUM):
                            velocity0.append(data_val*self.MM_TO_M)
                        else: 
                            self.set_data(label, data_val*self.MM_TO_M)

                # rotate velocity vector to account for pitch bias
                if velocity0:
                    #u,v,w  = self.apply_mounting_bias_rotations(velocity0)
                    u,v,w  = self.apply_sound_speed_correction(velocity0)
                    u,v,w  = self.apply_instr_to_earth((u,v,w))
                    xlabel = self.get_profile_var_name(var_name,bin_num,beam_u)
                    ylabel = self.get_profile_var_name(var_name,bin_num,beam_v)
                    zlabel = self.get_profile_var_name(var_name,bin_num,beam_w)
                    self.set_data(xlabel, u)
                    self.set_data(ylabel, v)
                    self.set_data(zlabel, w)


    def parse_system_configuration(self, verbose=True):
        """Parses system configuration setting and prints out result.

        Requires that system_configuration is in base 10 number format.
        """
        # convert base-10 to binary string
        sys_str       = bin(self.system_configuration)[2:][::-1]
        lagging_zeros = 16 - len(sys_str)
        sys_str      += '0'*lagging_zeros

        # separate the sections of the system configuration message
        hz_bin                  = sys_str[0:3]
        beam_pattern_bin        = sys_str[3:4]
        sensor_config_bin       = sys_str[4:6]
        transducer_attached_bin = sys_str[6:7]
        upwards_facing_bin      = sys_str[7:8]
        beam_angle_bin          = sys_str[8:10]
        janus_config_bin        = sys_str[12:16]

        # parse hz setting 
        if   hz_bin == '000': hz_set = '75kHz System'
        elif hz_bin == '100': hz_set = '150kHz System'
        elif hz_bin == '010': hz_set = '300kHz System'
        elif hz_bin == '110': hz_set = '600kHz System'
        elif hz_bin == '001': hz_set = '1200kHz System'
        elif hz_bin == '101': hz_set = '2400kHz System'

        # parse beam configuration
        if   beam_pattern_bin == '0': beam_pattern_set = 'Concave Beam Pattern'
        elif beam_pattern_bin == '1': beam_pattern_set = 'Convex Beam Pattern'

        # parse sensor configuration
        if   sensor_config_bin == '00': sensor_config_set = 'Sensor Config #1'
        elif sensor_config_bin == '10': sensor_config_set = 'Sensor Config #2'
        elif sensor_config_bin == '01': sensor_config_set = 'Sensor Config #3'

        # parse transducer attached 
        if transducer_attached_bin == '0': 
            transducer_attached_set = 'Not Attached'
        elif transducer_attached_bin == '1': 
            transducer_attached_set = 'Attached'

        # parse upward facing  
        if   upwards_facing_bin == '0': upwards_facing_set = 'Down Facing'
        elif upwards_facing_bin == '1': upwards_facing_set = 'Up Facing'

        # parse beam angle
        if   beam_angle_bin == '00': beam_angle_set = '15E Beam Angle'
        elif beam_angle_bin == '10': beam_angle_set = '20E Beam Angle'
        elif beam_angle_bin == '01': beam_angle_set = '30E Beam Angle'
        elif beam_angle_bin == '11': beam_angle_set = 'Other Beam Angle'

        # parse janus config
        if janus_config_bin == '0010': 
            janus_config_set = '4 Beam Janus'
        elif janus_config_bin == '1010': 
            janus_config_set = '5 Beam Janus, 3 Demod'
        elif janus_config_bin == '1111': 
            janus_config_set = '5 Beam Janus, 2 Demod'

        # print out the sensor configuration if requested
        if verbose:
            print('- Sensor Configuration -----------------')
            print('    ' + hz_set)
            print('    ' + beam_pattern_set)
            print('    ' + sensor_config_set)
            print('    ' + transducer_attached_set)
            print('    ' + upwards_facing_set)
            print('    ' + beam_angle_set)
            print('    ' + janus_config_set)


    def parse_coordinate_transformation(self, verbose=True):
        """Parses coordinate transformation setting and prints out result.

        Requires that coordinate_transformation is in base 10 number format.
        """
        # convert base-10 number to binary string 
        ctf_str = bin(self.coordinate_transformation)[2:][::-1]
        lagging_zeros = 8 - len(ctf_str)
        ctf_str += '0'*lagging_zeros

        # separate the sections of the system configuration message
        bin_mapping_bin      = ctf_str[0:1]
        three_beam_used_bin  = ctf_str[1:2]
        tilts_used_bin       = ctf_str[2:3]
        coord_frame_bin      = ctf_str[3:5]

        # parse bin mapping setting 
        if   bin_mapping_bin == '1': bin_mapping_set = 'Bin Mapping Used'
        elif bin_mapping_bin == '0': bin_mapping_set = 'Bin Mapping Not Used'

        # parse three beam solution setting 
        if three_beam_used_bin == '1': 
            three_beam_used_set = '3-Beam Soln Used'
        elif three_beam_used_bin == '0': 
            three_beam_used_set = '3-Beam Soln Not Used'

        # parse tilts setting 
        if   tilts_used_bin == '1': tilts_used_set = 'Tilts Used'
        elif tilts_used_bin == '0': tilts_used_set = 'Tilts Not Used'

        # parse coordinate transformation setting
        if   coord_frame_bin == '00': coord_frame_set = 'Beam Coords'
        elif coord_frame_bin == '10': coord_frame_set = 'Instrument Coords'
        elif coord_frame_bin == '01': coord_frame_set = 'Ship Coords'
        elif coord_frame_bin == '11': coord_frame_set = 'Earth Coords'

        # print out the coordinate transformation if requested 
        if verbose:
            print('- Coordinate Transformation ------------')
            print('    ' + bin_mapping_set)
            print('    ' + three_beam_used_set)
            print('    ' + tilts_used_set)
            print('    ' + coord_frame_set)

        return coord_frame_set

